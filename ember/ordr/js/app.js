var App = Ember.Application.create();
// var App is a namespace to write all of our application code
// namespace can be anything you like - but App is common
// this single line boots ember, set up all controllers, views, and template rendering that is needed
// to see this, we'll actually need to render something - which we'll do in the HTML file
// note that this single line of code also generates the index route and controller, and renders it templates

// Router - define a bunch of resources, each of which handle different actions in the application
// each resource is a part of a URL, and optionally followed by some additional information about what to do at that URL
// this additional information is optional only because ember generates sensible defaults when they are not present

//we define each of the resources that we are interested in
//each resource maps to a single route object
//routes can have sub routes (called nested routes)
//NOTE App.Router - not App.Route
App.Router.map(function() {
	// '/'' => 'index'  this mapping is always generated by default - no need to specify
	//now we wish to add a resource that is mapped from the URL hash: '/tables/:table_id'
	this.resource('tables', function() {
		this.resource('table', {
			//if path is not specified, it will be implied to be the name of the resource
			//since this resource is nested, its full path would be parent path + own path:
			// 'tables' + '/' + ':table_id'
			path: ':table_id'
		});
	});
	// this will take us to the tables route - which we'll add to HTML
	//visiting an ember route goes through a sequence of objects when rendering objects
	//to the screen, one of them is the route object (singular)
});

//but if we want some data to be available across all controllers in the app..
//we can use a special route - the application route. it has been generated implicitly all this while
//- since we haven't needed to use it thus far, we have not needed to write it
App.ApplicationRoute = Ember.Route.extend({
    //the setup controller method is useful for setting up cross controller activity
    //(when we need to work with multiple controllers)
    setupController: function() {
        //we can load data for any of the routes in this application in this method
        //the data we want to set for the food controller is obtained using: App.Food.find()
        //the food controller can be accessed using: this.controllerFor('food')
        //TODO find out why it is this.controllerFor instead of App.controllerFor -
        //the latter seems more intuitive, and using this seems more like an artefact of implementation detail
        this.controllerFor('food').set('model', App.Food.find());
    }
});

//name of route must correspond to the name of the resource above
//custom objects in ember use extend as a means of inheritance
App.TablesRoute = Ember.Route.extend({
	//in the route, implement the model method to return the data that is required
	//to be displayed - that should be used by the matching controller (tables controller)
	model: function() {
		//the return value is used to set the model property of the corresponding controller
		//at this stage, if you refresh the page, the page will not display anything,
		//as there will be an error - TableModel has yet to be defined
		return App.Table.find();
	}
});

//ember actually generates this route automatically in memory when it is not specified
//only really need to write this code if you want to do anything special
//you get this for free just by following the naming conventions
//We temporarily uncoimment this route to insert a debugger statement to inspect the value of params
//App.TableRoute = Ember.Route.extend({
//	//since this route has a path with a variable, we can access it using the params object
//	model: function(params) {
//        console.log('TableRoute#model params', params);
//		return App.Table.find(params.table_id);
//	}
//});

//an array controller expects its model to be a list of object models
App.TablesController = Ember.ArrayController.extend();

//ember actually generates this controller automatically in memory when not specified
//write this code only if you wish to override the default behaviour
//App.TableController = Ember.ObjectController.extend();

//this is our custom controller
//array controller because it manages a list of objects
//but how do we load the data for this controller?
//- we cannot load the data in controllers
//- there is no route object that corresponds to this controller to load the data into its model property
//nested resources are one way to load resources from another controller
App.FoodController = Ember.ArrayController.extend();

App.TabController = Ember.ObjectController.extend();

App.Store = DS.Store.extend({
	revision: 11,
	adapter: 'DS.FixtureAdapter'
});

App.Table = DS.Model.extend();

//models backed by a fixture adapter data store will be defined in a POJSO
//the only requirement is that each of them has an id attribute - which may be
//either a number or a string
//copied from models.js
// Models
//create a simple data model
//ember expects the name of the data store object to be store
//this is the object it will look in when you used .find(), etc, to get any models
App.Store = DS.Store.extend({
    //ember data is still ina  state of flux - so specifying a revision number is
    //similar to specifying a API version
    revision: 11,
    //DS.FixtureAdapter is an object, but we use a string instead because that lets
    //ember load/ initialise this object when it wants to later on,
    //instead of forcing it to do so now, when this store is specified
    adapter: 'DS.FixtureAdapter'
});

//define the model to be bound to this data store we have just created
App.Table = DS.Model.extend({
    //we define the relationship between the table model adn the table model: table belongs to a tab
    //the tab model is referred to here as a string, for the same reason that DS fixture adapter is above:
    //to allow ember to load/ init this object when it want to later on, instead of forcing it to do so right now
    //exception to the rule: you should never use 'App' or 'App.' in a string anywhere else
    //belongs to really means has one
    tab: DS.belongsTo('App.Tab')
});

App.Tab = DS.Model.extend({
    //relationship between tab model: tab has many tab items
    tabItems: DS.hasMany('App.TabItem'),
    cents: function() {
        //within this function we have access to the other properties of this objects - tab items
        return 100; //hard code this value for now
    }.property('tabItems.@each.cents')
    //we should also optimise this calculation by caching it so that it is only computed once
    //in addition, it should be recomputed any time the tab items change, and notify ember of this change
    //in ember we do this by calling .property after the closing squiggly brace of the function
    //we should pass in a description of the circumstances under which this property should be recomputed
    //this will often be the name of a simple property
    //in this case however, we are going for something more complex, and ember provides a expression language for this
});

App.TabItem = DS.Model.extend({
    //we define the the tab item model to contain an attribute
    //this means that objects saved into this model should have a cents attribute of type number
    //allowed attribute types are string, number, and boolean
    cents: DS.attr('number'),
    //relationship between tab item model and food model: tab item belongs to food
    food: DS.belongsTo('App.Food')
});

App.Food = DS.Model.extend({
    //food does not define any new relationships of its own
    name: DS.attr('string'),
    imageUrl: DS.attr('string'),
    cents: DS.attr('number')
});

//once the models have been defines, we populate them with data
//full featured ember data can retrieve data from a server,
//or you can do this manually by using AJAX to fetch JSON and populate the record manually from here
//we'll use fixtures here so that we do not need to rely on having a functional server while develop this app (the client)
//note that ember defines an id attribute for all models automatically, but we will need to specify this in the fixtures
//parent objects need to keep track of the keys of their child objects
App.Table.FIXTURES = [{
    id: 1,
    tab: 1 //belongs to
}, {
    id: 2,
    tab: 2
}, {
    id: 3,
    tab: 3
}, {
    id: 4,
    tab: 4
}, {
    id: 5,
    tab: 5
}, {
    id: 6,
    tab: 6
}];

App.Tab.FIXTURES = [{
    id: 1,
    tabItems: [] //has many
}, {
    id: 2,
    tabItems: []
}, {
    id: 3,
    tabItems: []
}, {
    id: 4,
    tabItems: [400, 401, 402, 403, 404]
}, {
    id: 5,
    tabItems: []
}, {
    id: 6,
    tabItems: []
}];

//ids do not need to start with 1 - use larger number for different classes for ease of debugging
App.TabItem.FIXTURES = [{
    id: 400,
    cents: 1500,
    food: 1
}, {
    id: 401,
    cents: 300,
    food: 2
}, {
    id: 402,
    cents: 700,
    food: 3
}, {
    id: 403,
    cents: 950,
    food: 4
}, {
    id: 404,
    cents: 2000,
    food: 5
}];

App.Food.FIXTURES = [{
    id: 1,
    name: 'Pizza',
    imageUrl: 'img/pizza.png',
    cents: 1500
}, {
    id: 2,
    name: 'Pancakes',
    imageUrl: 'img/pancakes.png',
    cents: 300
}, {
    id: 3,
    name: 'Fries',
    imageUrl: 'img/fries.png',
    cents: 700
}, {
    id: 4,
    name: 'Hot Dog',
    imageUrl: 'img/hotdog.png',
    cents: 950
}, {
    id: 5,
    name: 'Birthday Cake',
    imageUrl: 'img/birthdaycake.png',
    cents: 2000
}];
